"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _http = _interopRequireDefault(require("http"));

var _https = _interopRequireDefault(require("https"));

var _url = _interopRequireDefault(require("url"));

var _zlib = _interopRequireDefault(require("zlib"));

var _ConnectionError = _interopRequireDefault(require("./ConnectionError"));

var _ConsoleLogger = _interopRequireDefault(require("./ConsoleLogger"));

var _HTTPError = _interopRequireDefault(require("./HTTPError"));

var _ParseError = _interopRequireDefault(require("./ParseError"));

var _StreamReader = _interopRequireDefault(require("./StreamReader"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const BUILTIN_DEFAULTS = {
  agent: false,
  compression: ['gzip', 'deflate'],
  headers: {},
  json: false,
  logger: new _ConsoleLogger.default(),
  maxRedirects: 3,
  resolveWithFullResponse: false,
  verbose: false,
  timeout: 0
};
let USER_DEFAULTS = {};

class Request {
  static parseTransport(protocol) {
    switch (protocol) {
      case 'http:':
        return _http.default;

      case 'https:':
        return _https.default;

      default:
        throw new TypeError(`New Error: Invalid protocol ${protocol}`);
    }
  }

  static parseQuery(map) {
    if (typeof map !== 'object') {
      throw new TypeError('Invalid query string map');
    }

    const tokens = Object.keys(map).map(function (key) {
      const unparsedValues = map[key];
      const encodedKey = encodeURIComponent(key);
      let values;

      if (typeof unparsedValues === 'undefined') {
        return key;
      }

      if (Array.isArray(unparsedValues)) {
        values = unparsedValues.map(encodeURIComponent);
        return values.map(function (value) {
          return `${encodedKey}=${value}`;
        }).join('&');
      }

      values = [encodeURIComponent(unparsedValues)];
      return [encodeURIComponent(key), values.join(',')].join('=');
    });
    return tokens.join('&');
  }

  static parseUrl(url, options) {
    url = url || options.url;

    const parsed = _url.default.parse(url);

    if (options.qs) {
      parsed.search = Request.parseQuery(options.qs);
    }

    const formatted = _url.default.format(parsed);

    const regex = /^(https?|ftp):\/\/[^\s/$.?#].[^\s]*$/i;

    if (!regex.test(formatted)) {
      throw new TypeError(`Invalid URL: ${formatted}`);
    }

    return _url.default.parse(formatted);
  }

  static parseMethod(method) {
    if (_http.default.METHODS.indexOf(method) !== -1) {
      return method;
    }

    throw new TypeError(`Invalid method '${method}'`);
  }

  static get defaults() {
    const ENV_DEFAULTS = process.env.RPL_DEFAULTS ? JSON.parse(process.env.RPL_DEFAULTS) : {};
    return _objectSpread({}, BUILTIN_DEFAULTS, {}, ENV_DEFAULTS, {}, USER_DEFAULTS);
  }

  static set defaults(defaults) {
    if (typeof defaults !== 'object') {
      const message = `Invalid defaults '${defaults}', expecting an object`;
      throw new TypeError(message);
    }

    USER_DEFAULTS = defaults;
    return Request.defaults;
  }

  constructor(method, url, options) {
    options = options || {};
    this.method = Request.parseMethod(method);
    this.url = Request.parseUrl(url, options);
    this.transport = Request.parseTransport(this.url.protocol);
    this.options = _objectSpread({}, Request.defaults, {}, options);
    this.parseOptions();
  }

  parseOptions() {
    const {
      method,
      options,
      url
    } = this;
    const transportOptions = {
      method,
      agent: options.agent,
      hostname: url.hostname,
      port: url.port,
      path: url.path,
      headers: options.headers,
      pfx: options.pfx,
      passphrase: options.passphrase,
      rejectUnauthorized: options.rejectUnauthorized,
      timeout: options.timeout
    };
    const {
      auth,
      compression,
      form,
      logger
    } = options;
    let {
      body
    } = options;

    if (options.json === true) {
      transportOptions.headers.Accept = 'application/json';

      if (typeof body !== typeof undefined) {
        transportOptions.headers['Content-Type'] = 'application/json';
        body = JSON.stringify(body);
      }
    }

    if (typeof form !== typeof undefined) {
      if (typeof form !== 'object') {
        throw new TypeError('Incompatible form data: ', form);
      }

      body = Request.parseQuery(form);
      transportOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
      transportOptions.headers.Accept = 'application/json';
    }

    if (typeof auth !== typeof undefined) {
      if (typeof auth !== 'object') {
        throw new TypeError('Incompatible auth data', auth);
      }

      const user = auth.user || auth.username;
      const password = auth.pass || auth.password;
      transportOptions.auth = `${user}:${password}`;
    }

    if (typeof compression !== typeof undefined) {
      const supported = ['gzip', 'deflate'];

      if (!Array.isArray(compression) || compression.some(function (v1) {
        return !supported.some(function (v2) {
          return v1 === v2;
        });
      })) {
        const message = `Invalid compression scheme, '${compression}', expecting string array`;
        throw new TypeError(message);
      }

      transportOptions.headers['Accept-Encoding'] = compression.join(', ');
    }

    this.transportOptions = transportOptions;
    this.body = body;
    this.logger = logger;
  }

  run() {
    var _this2 = this;

    return this.handleRequest().then(function (response) {
      return _this2.handleResponse(response);
    });
  }

  createResponse(response, body) {
    if (this.options.json) {
      const str = body.toString();

      if (str.length === 0) {
        body = null;
      } else {
        try {
          body = JSON.parse(str);
        } catch (error) {
          throw new _ParseError.default(`Invalid JSON: '${body}'`, error.message);
        }
      }
    }

    if (this.options.resolveWithFullResponse) {
      response.body = body;
      return response;
    }

    return body;
  }

  handleResponse(res) {
    var _this3 = this;

    const status = res.statusCode;

    const _this = this;

    if (this.options.verbose) {
      this.logger.debug('Response status: %s', res.statusCode);
      this.logger.debug('Response headers: %j', res.headers);
    }

    if (status >= 301 && status <= 303) {
      const {
        location
      } = res.headers;
      const {
        options
      } = _this;
      res.resume();

      if (options.maxRedirects < 1) {
        const message = `Too many redirects to handle ${status}`;
        return Promise.reject(new _ConnectionError.default(message));
      }

      const newOpts = _objectSpread({}, options);

      if (typeof newOpts.qs !== 'undefined') {
        delete newOpts.qs;
      }

      newOpts.maxRedirects = options.maxRedirects - 1;
      const request = new Request(_this.method, location, newOpts);
      return request.handleRequest().then(function (response) {
        return request.handleResponse(response);
      });
    }

    const encoding = res.headers['content-encoding'] || '';
    let readStream;

    switch (encoding) {
      case '':
        readStream = res;
        break;

      case 'gzip':
        readStream = res.pipe(_zlib.default.createGunzip());
        break;

      case 'deflate':
        readStream = res.pipe(_zlib.default.createInflate());
        break;

      default:
        return Promise.reject(new _ParseError.default(`Invalid response encoding: '${encoding}'`));
    }

    const reader = new _StreamReader.default(readStream);
    return reader.readAll().then(function (body) {
      if (_this.options.verbose) {
        const decodedBody = body instanceof Buffer ? body.toString() : JSON.stringify(body);

        _this.logger.debug('Response body: %s', decodedBody);
      }

      if (status >= 200 && status < 300) {
        return Promise.resolve(_this3.createResponse(res, body));
      }

      const response = _this3.createResponse(res, body);

      const error = new _HTTPError.default('Error in response', status, response);
      return Promise.reject(error);
    }, function (error) {
      const message = `Error reading the response: ${error.message}`;
      return Promise.reject(new _ConnectionError.default(message, error.message));
    });
  }

  handleRequest() {
    var _this4 = this;

    const _this = this;

    return new Promise(function (resolve, reject) {
      const {
        body
      } = _this;

      if (_this.options.verbose) {
        const decodedBody = body instanceof Buffer ? body.toString() : JSON.stringify(body);

        _this.logger.debug('Request URL: %j', _this.url);

        _this.logger.debug('Request headers: %j', _this.transportOptions.headers);

        _this.logger.debug('Request body: %s', decodedBody);
      }

      const {
        transport,
        transportOptions
      } = _this;
      const req = transport.request(transportOptions);
      req.on('abort', function () {
        const rawMessage = 'Client aborted the request';
        const message = `Connection failed: ${rawMessage}`;
        reject(new _ConnectionError.default(message, rawMessage));
      });
      req.on('aborted', function () {
        const rawMessage = 'Server aborted the request';
        const message = `Connection failed: ${rawMessage}`;
        reject(new _ConnectionError.default(message, rawMessage));
      });
      req.on('error', function (error) {
        const message = `Connection failed: ${error.message}`;
        reject(new _ConnectionError.default(message, error.message));
      });
      req.on('response', function (response) {
        resolve(response);
      });

      if (transportOptions.timeout > 0) {
        req.setTimeout(transportOptions.timeout, function () {
          return req.abort();
        });
      }

      req.end(_this4.body);
    });
  }

}

exports.default = Request;
module.exports = exports.default;
//# sourceMappingURL=Request.js.map